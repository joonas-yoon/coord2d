<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Coord Plane Viewer</title>

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <style>
      html, body { width:  100%; height: 100%; margin: 0; padding: 0; }
      div { box-sizing: border-box; }
      #canvas { overflow: hidden; }
    </style>
  </head>
  <body>
      <div class="container">
        <div class="col" style="position: absolute; left: 0; display:block; width: 300px; height: 100vh; box-shadow: 2px 0px 5px rgb(0,0,0,.2);">
          <div id="editor" style="width: 300px; height: 500px;">50 30
10 20
60 30
40
30.5 20
10
40,10
-20 60 90 60
-50 -90 80 60</div>
        </div>
        <div class="col" style="position: absolute; left: 300px; display:block; width: calc(100% - 300px); height: 100vh;">
          <canvas id="canvas" style="width: 100%; height: 100%;"></canvas>
        </div>
      </div>

      <script src="https://pagecdn.io/lib/ace/1.4.5/ace.js" integrity="sha256-5Xkhn3k/1rbXB+Q/DX/2RuAtaB4dRRyQvMs83prFjpM=" crossorigin="anonymous"></script>
      <script>
        const editor = ace.edit("editor");

        function toValidFormat(text) {
          const ret = [];
          text = text.replace(/\n+/g, '\n');
          for (const s of text.split('\n')) {
            let l = s.trim().split(/\s|,/).map((x) => Number(x));
            if (l.length < 2) l.push(0);
            ret.push(l);
          }
          return ret;
        }

        class CoordPlane {
          constructor(canvas) {
            this.points = [];
            this.canvas = canvas;
            this.context = canvas.getContext('2d');
            this.container = canvas.parentElement;
            this.left = -canvas.width / 2;
            this.top = -canvas.height / 2;
            this.right = canvas.width / 2;
            this.bottom = canvas.height / 2;
            this.originX = -this.left;
            this.originY = -this.top;
            this.zoomFactorX = 1;
            this.zoomFactorY = 1;
          }

          static drawLine(context, x1, y1, x2, y2, color) {
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.lineWidth = 1;
            context.strokeStyle = color || '#000';
            context.stroke();
            context.closePath();
          }

          static drawCircle(context, x1, y1, radius, color) {
            context.beginPath();
            context.arc(x1, y1, radius, 0, 2 * Math.PI);
            context.strokeStyle = color || '#000';
            context.fill();
            context.closePath();
          }

          setPoints(points) {
            this.points = points;
          }

          setViewport(left, top, right, bottom) {
            // zoom factor
            const {width, height} = this.canvas;
            const zx = width / (right - left);
            const zy = height / (bottom - top);
            if (zx < 0.01 || zx > 100 || zy < 0.01 || zy > 100) return;
            this.zoomFactorX = zx;
            this.zoomFactorY = zy;
            // set viewport bounds
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
            this.originX = -this.left;
            this.originY = -this.top;
          }

          moveViewport(dx, dy) {
            dx /= this.zoomFactorX;
            dy /= this.zoomFactorY;
            const width = this.right - this.left;
            const height = this.bottom - this.top;
            const left = this.left + dx, top = this.top + dy;
            const right = left + width;
            const bottom = top + height;
            this.setViewport(left, top, right, bottom);
          }

          fit(container, factor) {
            factor = factor || 2;
            // fit to container
            this.container = container;
            const bounds = container.getBoundingClientRect();
            this.canvas.width  = bounds.width || window.innerWidth;
            this.canvas.height = bounds.height || window.innerHeight;
            this.setViewport(-bounds.width / factor, -bounds.height / factor, bounds.width / factor, bounds.height / factor);
          }
          
          draw() {
            // config variables
            const { points, canvas, context, left, top, right, bottom } = this;
            const { originX, originY, zoomFactorX, zoomFactorY } = this;
            const {width, height} = canvas;
            const delta = 10;
            const radius = 3, fontSize = 16;
            // clear before draw
            context.clearRect(0, 0, canvas.width, canvas.height);
            // horizonal line
            for (let i = -top % delta; zoomFactorY * i <= height; i += delta) {
              const y = zoomFactorY * i;
              CoordPlane.drawLine(context, 0, y, width, y, i == originY ? '#333' : '#ccc');
            }
            // vertical line
            for (let i = -left % delta; zoomFactorX * i <= width; i += delta) {
              const x = zoomFactorX * i;
              CoordPlane.drawLine(context, x, 0, x, height, i == originX ? '#333' : '#ccc');
            }
            // draw points
            let vertexId = 1;
            for (const p of points) {
              if (p.length == 2) {
                const x = zoomFactorX * (originX + p[0]);
                const y = zoomFactorY * (originY - p[1]);
                CoordPlane.drawCircle(context, x, y, radius);
                context.font = `${fontSize}px Consolas`;
                context.fillText(vertexId++, x, y + fontSize);
              } else if (p.length == 4) {
                const x1 = zoomFactorX * (originX + p[0]);
                const y1 = zoomFactorY * (originY - p[1]);
                const x2 = zoomFactorX * (originX + p[2]);
                const y2 = zoomFactorY * (originY - p[3]);
                CoordPlane.drawCircle(context, x1, y1, radius);
                CoordPlane.drawCircle(context, x2, y2, radius);
                CoordPlane.drawLine(context, x1, y1, x2, y2, '#000');
                context.font = `${fontSize}px Consolas`;
                context.fillText(vertexId++, (x1 + x2) / 2, (y1 + y2) / 2 + fontSize);
              }
            }
          }
          
          render() {
            if (this.points && this.points.length) {
              this.draw();
            }
          }
        }

        function setup(){
          // start process
          const canvas = document.getElementById("canvas");
          const plane = new CoordPlane(canvas);

          let lastY = null, lastX, isDragged = false;
          canvas.addEventListener("mousedown", (evt) => { isDragged = true; });
          canvas.addEventListener("mouseup", (evt) => { isDragged = false; });
          canvas.addEventListener("mousemove", (evt) => {
            if (isDragged) {
              plane.moveViewport(lastX - evt.offsetX, lastY - evt.offsetY);
              plane.render();
            }
            lastY = evt.offsetY;
            lastX = evt.offsetX;
          });
          canvas.addEventListener("mousewheel", (evt) => {
            evt.preventDefault();
            zoom(evt.deltaY);
          });

          function initSize() {
            plane.fit(canvas.parentElement, 10);
          }

          function render(evt) {
            const points = toValidFormat(editor.getValue());
            if (points && points.length) plane.setPoints(points);
            plane.render();
          }

          function zoom(delta) {
            const ratio = canvas.width / canvas.height;
            delta = 5 * (plane.right - plane.left) / delta;
            const deltaX = delta * ratio;
            const deltaY = delta;
            plane.setViewport(
              plane.left - deltaX, plane.top - deltaY,
              plane.right + deltaX, plane.bottom + deltaY
            )
            plane.render();
          }

          var optimizedResize = (function() {
            var callbacks = [],
                running = false;

            // fired on resize event
            function resize() {
              if (!running) {
                running = true;
                if (window.requestAnimationFrame) {
                  window.requestAnimationFrame(runCallbacks);
                } else {
                  setTimeout(runCallbacks, 66);
                }
              }
            }

            // run the actual callbacks
            function runCallbacks() {
              callbacks.forEach(function(callback) {
                callback();
              });
              running = false;
            }

            // adds callback to loop
            function addCallback(callback) {
              if (callback) {
                callbacks.push(callback);
              }
            }

            return {
              // public method to add additional callback
              add: function(callback) {
                if (!callbacks.length) {
                  window.addEventListener('resize', resize);
                }
                addCallback(callback);
              }
            }
          }());

          optimizedResize.add(() => {
            initSize();
            render();
          });
          editor.on("change", render);
          initSize();
          render();
        }
        
        (function() {
          window.addEventListener("load", () => {
            setTimeout(setup, 100);
          });
        })();
      </script>
  </body>
</html>